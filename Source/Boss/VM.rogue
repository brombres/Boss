module Boss

class VM [singleton]
  PROPERTIES
    t                 = Token( TokenType.IDENTIFIER, "[Boss]", &content="Boss" )
    new_elements      : [String:ProgramElements]
    resolved_elements : [String:ProgramElements]
    include_folders   = Set<<String>>().[ add("") ]

    native_types          = [String:NativeTypeInfo]
    native_constructors   = [String:Cmd]
    native_global_methods = [String:Cmd]
    native_methods        = [String:Cmd]
    native_definitions    = [String:String]
    definitions           = [String:Cmd]

    program : Program
    stack   = Variant[]
    fp      : Int

    resolve_filepath = (filepath) => filepath : Function(String)->String

  METHODS # External runtime API
    method init
      forEach (type in TypeInfo)
        contingent
          necessary (type.module_context == "Rogue")
          sufficient (type.name.begins_with("Function_"))
          sufficient (type.name.begins_with("Augment_"))

          sufficient (type.name.contains("<<"))
          sufficient (type.name.ends_with(']'))
          sufficient (type.name.ends_with('?'))
          sufficient (type.name.begins_with('('))

          which (type.scoped_name)
            case "Rogue::Object", "Rogue::Random"
              .bind_native_type( type )
            others
              #trace type.scoped_name
          endWhich
        endContingent
      endForEach

    method compile( script:String )->(Function->Variant)
      launch

      temporarily VM=this, Program=program
        local statements = Parser( "[EXECUTE]", script ).parse( Parser.ip_multi_line_statements )->(as Statements)
        local m_execute = GlobalMethod( statements.t, "execute", &statements=statements )
        m_execute.type_context = Program.default_module.type( Program.default_module.t, "Routine" )
        Resolver.resolve( m_execute )
        return function()->Variant with (vm=this)
          temporarily VM=vm, Program=program
            return program.execute( m_execute )
          endTemporarily
        endFunction
      endTemporarily

    method execute( script:String )->Variant
      return compile(script)()

    method .bind_native_type( type:TypeInfo )
      local info = NativeTypeInfo( type )
      info.create_object = () => type.create_object
      info.instance_of = (v) => v? and v->Object.type_info.instance_of(type)
      if (type.is_singleton)
        info.get_singleton = () => type.singleton
        info.set_singleton = (new_value) => type.singleton = new_value
        if local base_class = type.base_class
          info.base_class_name = base_class.scoped_name
        endIf
      endIf
      register_type( type.scoped_name, info )

      forEach (m in type.methods)
        .register_native_method( m )
      endForEach

    method .register_native_method( m:MethodInfo )
      contingent # FIXME
        necessary (m.parameters.is_empty)
        sufficient (not m.return_type)
        sufficient (m.return_type.scoped_name == "Rogue::Int")
        sufficient (m.return_type.scoped_name == "Rogue::Int32")
        sufficient (m.return_type.scoped_name == "Rogue::Logical")
        necessary (m.return_type.scoped_name == "Rogue::Real")
      unsatisfied
        return
      endContingent
      local sig = "$.$"(m.type_context.scoped_name,m.signature)
      if (m.return_type) sig = "$->$"(sig,m.return_type.scoped_name)
      register_method( sig, () => m.boss_call_method )

  METHODS # Internal runtime API
    method context->Variant
      return stack[fp]

    method context_object->Rogue::Object
      if local obj = stack[fp].object
        return obj
      else
        throw BossNullReferenceError
      endIf

    method int( index:Int )->Int
      return stack[fp+index]->Int

    method logical( index:Int )->Int
      return stack[fp+index]?

    method call_method( context:Variant, m:Procedure, args=null:Args )->Variant
      local old_stack_count = stack.count
      stack.add( context )

      if (args and args.count) stack.add( (forEach in args).execute )

      local result = m.execute
      stack.discard_from( old_stack_count )
      return result

    method create_object( of_type:Type, &no_init )->Variant
      local obj : Variant
      if local create_fn = of_type.native_type.create_boss_object
        obj = create_fn( of_type )
      else
        obj = BossObject( of_type )
      endIf
      if (of_type.m_init_object) call_method( obj, of_type.m_init_object )
      if (not no_init and of_type.m_init) call_method( obj, of_type.m_init )
      return obj

    method create_object( of_type:Type, m_init:Procedure, args:Args )->Variant
      local obj = Variant( BossObject(of_type) )
      call_method( obj, m_init, args )
      return obj

    method find_global_method( scoped_signature:String )->GlobalMethod
      local type = Program.default_module.find_type( scoped_signature.before_first('.') )
      if (not type) return null
      return type.global_methods[ scoped_signature.after_first('.') ]

    method find_method( scoped_signature:String )->Method
      local type = Program.default_module.find_type( scoped_signature.before_first('.') )
      if (not type) return null
      return type.methods[ scoped_signature.after_first('.') ]

    method parameter( index:Int )->Variant
      # First parameter is index 1.
      return stack[fp+index]

    method real( index:Int )->Real
      return stack[fp+index]->Real

    method string( index:Int )->String
      return stack[fp+index]->String

    method xy( index:Int )->XY
      return stack[fp+index]->XY

  METHODS # Configuration
    method deregister_constructor( signature:String )
      if (native_constructors.remove(signature)) .begin_staging

    method deregister_global_method( full_signature:String )
      if (native_global_methods.remove(full_signature)) .begin_staging

    method deregister_method( full_signature:String )
      if (native_methods.remove(full_signature)) .begin_staging

    method deregister_type( scoped_name:String )
      if (native_types.remove(scoped_name)) .begin_staging

    method include( file:File, &suppress_error )->Logical
      # Loads file if not already loaded.
      if local found_file = .find_file( file )
        local filepath = found_file.filepath
        if (new_elements and new_elements.contains(filepath)) return true
        return load( found_file, &=suppress_error )
      else
        if (suppress_error) return false
        throw CompileError( "File not found: $"(file) )
      endIf

    method launch
      try
        temporarily VM = this
          if (new_elements and new_elements.count)
            local staged_program = Program( new_elements.values )
            resolved_elements = new_elements
            new_elements = null
            staged_program.organize
            staged_program.resolve
            staged_program.launch
            program = staged_program
          elseIf (not program)
            program = Program()
            program.organize
            program.resolve
            program.launch
          endIf
        endTemporarily
      catch (error:Exception)
        new_elements = null
        throw error
      endTry

    method load( file:File, &suppress_error )->Logical
      if local found_file = .find_file( file )
        file = found_file
      else
        if (suppress_error) return false
        throw BossError( "File not found: " + file )
      endIf

      return load( file, String(file), &=suppress_error )

    method load( file:File, source:String, &suppress_error )->Logical
      .begin_staging

      try
        temporarily VM = this
          local elements = Parser( file, source ).parse->(as ProgramElements)
          new_elements[file.filepath] = elements
          (forEach in elements).preprocess
        endTemporarily

      catch (error:Exception)
        new_elements = null
        if (suppress_error) return false
        throw error

      endTry

      return true

    method register_constructor( signature:String, cmd:Cmd )
      native_constructors[signature] = cmd
      .begin_staging

    method register_constructor( full_signature:String, callback:Function()->Variant )
      register_constructor( full_signature, CallNativeMethod(t,callback) )

    method register_definition( scoped_name:String, value:String )
      # E.g. register_definition( "Int.BITS", "64" )
      # E.g. register_definition( "Rogue::Int.BITS", "64" )
      native_definitions[scoped_name] = value

    method register_global_method( full_signature:String, cmd:Cmd )
      native_global_methods[full_signature] = cmd
      .begin_staging

    method register_global_method( full_signature:String, callback:Function()->Variant )
      register_global_method( full_signature, CallNativeMethod(t,callback) )

    method register_method( full_signature:String, cmd:Cmd )
      native_methods[full_signature] = cmd
      .begin_staging

    method register_method( full_signature:String, callback:Function()->Variant )
      register_method( full_signature, CallNativeMethod(t,callback) )

    method register_type( scoped_name:String, info=NativeTypeInfo():NativeTypeInfo )
      native_types[scoped_name] = info

    method unload( file:File )
      .begin_staging

      local filepath = file.abs.filepath
      new_elements.remove( filepath )
      resolved_elements?.remove( filepath )

    method update
      try
        launch
      catch (error:Exception)
        new_elements = null
        throw error
      endTry

    method .begin_staging
      if (not new_elements)
        if (resolved_elements)
          new_elements = resolved_elements.cloned
        else
          new_elements = [String:ProgramElements]
        endIf
      endIf

    method .find_file( file:File )->File?
      local found_file = File( resolve_filepath(file) )
      contingent
        sufficient (found_file.exists)

        forEach (folder in include_folders)
          found_file = File( resolve_filepath(folder / file) )
          if (not found_file.exists)
            found_file = File( resolve_filepath(found_file.with_extension(".boss")) )
            if (not found_file.exists)
              found_file = File( resolve_filepath(found_file.with_extension(".rogue")) )
            endIf
          endIf
          sufficient (found_file.exists)
        endForEach

        return null

      satisfied
        file = found_file
      endContingent

      if (file.is_folder)
        found_file = (file / file.filename) + ".boss"  # try primary extension
        if (not found_file.exists) found_file = (file / file.filename) + ".rogue"  # try secondary extension
        if (not found_file.exists) return null
        file = found_file
      endIf

      file .= abs

      local folder = file.abs.folder
      include_folders[folder] = folder

      return file

endClass
