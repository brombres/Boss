module Boss

$localMacro GENERAL_OP_RESOLVE<<$Cmd,$op>>
augment Resolver
  METHODS
    method on_visit( cmd:$Cmd )->Cmd
      local left  = visit( cmd.left )
      local right = visit( cmd.right )
      local common_type = find_compatible_type( left, right )

      left = convert_to( left, common_type )
      right = convert_to( right, common_type )

      if (common_type is Program.type_Real)
        return validate( $id($Cmd,Real)(cmd.t,left,right) )
      elseIf (common_type is Program.type_Int)
        return validate( $id($Cmd,Int)(cmd.t,left,right) )
      endIf

      throw cmd.t.error( $string("[INTERNAL] Unhandled operation: $ ",$op," $")(common_type,common_type) )
endAugment
$endLocalMacro


$localMacro GENERAL_OP_EXECUTE<<$Cmd,$op>>
augment
  METHODS
    method $id($Cmd,Int).type->Type
      return Program.type_Int

    method $id($Cmd,Int).execute->Variant
      local left_value = left.execute
      local right_value = right.execute
      return Variant( left_value.integer $op right_value.integer )

    method $id($Cmd,Real).type->Type
      return Program.type_Real

    method $id($Cmd,Real).execute->Variant
      local left_value = left.execute
      local right_value = right.execute
      return Variant( left_value.real $op right_value.real )
endAugment
$endLocalMacro


$localMacro MATH_OP<<$Cmd,$op>>

GENERAL_OP_RESOLVE<< $Cmd, $op >>
GENERAL_OP_EXECUTE<< $Cmd, $op >>

augment Resolver
  METHODS
    method on_validate( cmd:$id($Cmd,Int) )->Cmd
      if local left_literal = cmd.left->(as LiteralInt)
        if local right_literal = cmd.right->(as LiteralInt)
          return LiteralInt( cmd.t, left_literal.value $op right_literal.value )
        endIf
      endIf
      return cmd

    method on_validate( cmd:$id($Cmd,Real) )->Cmd
      if local left_literal = cmd.left->(as LiteralReal)
        if local right_literal = cmd.right->(as LiteralReal)
          return LiteralReal( cmd.t, left_literal.value $op right_literal.value )
        endIf
      endIf
      return cmd
endAugment
$endLocalMacro


$localMacro LOGICAL_OP<<$Cmd,$op>>

GENERAL_OP_RESOLVE<< $Cmd, $op >>

augment $id($Cmd,Int)
  METHODS
    method type->Type
      return Program.type_Logical

    method execute->Variant
      local left_value = left.execute
      local right_value = right.execute
      return Variant( left_value.integer $op right_value.integer )
endAugment

augment $id($Cmd,Real)
  METHODS
    method type->Type
      return Program.type_Logical

    method execute->Variant
      local left_value = left.execute
      local right_value = right.execute
      return Variant( left_value.real $op right_value.real )
endAugment
$endLocalMacro

MATH_OP<< Add,      + >>
MATH_OP<< Subtract, - >>
MATH_OP<< Multiply, * >>
MATH_OP<< Divide,   / >>
MATH_OP<< Mod,      % >>
MATH_OP<< Power,    ^ >>

LOGICAL_OP<< CompareEQ, == >>
LOGICAL_OP<< CompareNE, != >>
LOGICAL_OP<< CompareLT, <  >>
LOGICAL_OP<< CompareLE, <= >>
LOGICAL_OP<< CompareGT, >  >>
LOGICAL_OP<< CompareGE, >= >>

augment
  METHODS
    method Resolver.on_validate( cmd:DivideInt )->Cmd
      if local right_literal = cmd.right->(as LiteralInt)
        if (right_literal.value == 0) throw cmd.t.error( "Integer division by 0." )
        if local left_literal = cmd.left->(as LiteralInt)
          return LiteralInt( cmd.t, left_literal.value / right_literal.value )
        endIf
      endIf
      return cmd

    method DivideInt.execute->Variant
      local left_value = left.execute
      local right_value = right.execute
      if (right_value) return Variant( left_value.integer / right_value.integer )
      Global.error.println "[Integer division by 0]"
      return left_value

endAugment

class Resolver : Visitor [singleton]
  PROPERTIES
    scope_stack : ControlStructure[]

  METHODS
    method resolve_program
      use new_scope_stack_frame = WorkList<<ControlStructure>>
        temporarily scope_stack = new_scope_stack_frame
          visit_program( Program )
        endTemporarily
      endUse

    method visit_module( mod:Module ) [override]
      temporarily Program.current_module = mod
        (forEach in mod.types).resolve
      endTemporarily

    method resolve_type( type:Type )
      use new_scope_stack_frame = WorkList<<ControlStructure>>
        temporarily scope_stack = new_scope_stack_frame
          temporarily Program.current_module = type.module_context
            visit_type( type )
          endTemporarily
        endTemporarily
      endUse

    method resolve( procedure:Procedure )
      use new_scope_stack_frame = WorkList<<ControlStructure>>
        temporarily scope_stack = new_scope_stack_frame
          local type_context = procedure.type_context
          temporarily Program.current_module=type_context.module_context, this_type=type_context
            visit( procedure )
          endTemporarily
        endTemporarily
      endUse

    method add_local( t:Token, name:String, type:Type )->Local
      local v = Local( t, name, type )
      add_local( v )
      return v

    method add_local( identifier:Cmd, type:Type )->Local
      local v = Local( identifier.t, identifier->String, type )
      add_local( v )
      return v

    method add_local( v:Local )
      local existing_v = find_local( v.name )
      if (existing_v)
        if (v.index < this_procedure.param_count)
          throw v.t.error( ''A parameter named "$" already exists in the current scope.''(v.name) )
        else
          throw v.t.error( ''A local variable named "$" already exists in the current scope.''(v.name) )
        endIf
      endIf
      v.index = this_procedure.local_count
      ++this_procedure.local_count
      scope_stack.last.locals[v.name] = v

    method convert_to( cmd:Cmd, to_type:Type )->Cmd
      local cmd_type = cmd.require_type

      which (cmd_type)
        case to_type
          return cmd
        case Program.type_Int
          which (to_type)
            case Program.type_Real
              return validate( IntToReal(cmd.t,cmd) )
          endWhich
      endWhich

      throw cmd.t.error( "Cannot convert type $ to type $."(cmd_type,to_type) )

    method find_compatible_type( left:Cmd, right:Cmd )->Type
      local left_type = left.require_type
      local right_type = right.require_type
      if (left_type is right_type) return left_type

      if (left_type is Program.type_String or right_type is Program.type_String) return Program.type_String
      if (left_type is Program.type_Real or right_type is Program.type_Real) return Program.type_Real
      if (left_type is Program.type_Int or right_type is Program.type_Int) return Program.type_Int

      throw left.t.error( "Types $ and $ are incompatible."(left_type,right_type) )

    method find_local( name:String )->Local
      forEach (scope in scope_stack step -1)
        if local v = scope.locals[name]
          return v
        endIf
      endForEach
      return null

    method on_visit( cmd:Access )->Cmd
      which (cmd.name)
        case "print":   return Print( cmd.t, visit(cmd.args)->(as Args) )
        case "println": return Println( cmd.t, visit(cmd.args)->(as Args) )
      endWhich

      if local v = find_local( cmd.name )
        return visit( ReadLocal(cmd.t, v) )
      endIf

      if local type = Program.current_module.find_type( cmd.name )
        if (cmd.args)
          return visit( Construct(cmd.t,type,cmd.args) )

        elseIf (type.attributes.is_singleton)
          if (type.attributes.is_native_type)
            if (not type.native_get_singleton)
              throw cmd.t.error( "$ is a write-only singleton."(type.scoped_name) )
            endIf
            return visit( ReadNativeSingleton(cmd.t,type) )
          else
            trace
            throw cmd.t.error( "TODO: Boss Singleton" )
          endIf
        else
          return TypeContext( cmd.t, type )
        endIf
      endIf

      throw cmd.t.error( ''No such variable, method, or routine "$" exists in the current scope.''(cmd.name) )

    method on_visit( cmd:Assign )->Cmd
      return cmd.target.resolve_assignment( cmd.t, cmd.new_value, this )

    method on_validate( cmd:Binary )->Cmd
      cmd.left.require_type
      cmd.right.require_type
      return cmd

    method on_visit( cmd:Construct )->Cmd
      return resolve_access( cmd.t, cmd.@type, cmd, "init", cmd.args, &is_constructor )

    method on_visit( cmd:ControlStructure )->Cmd
      scope_stack.add( cmd )
      visit( cmd.statements )
      scope_stack.remove_last
      return cmd

    method on_visit( cmd:ContextAccess )->Cmd
      return visit( cmd.context ).resolve_context_access( cmd, this )

    method on_visit( cmd:ForEachIn )->Cmd
      cmd.collection = visit( cmd.collection )
      return cmd.collection.resolve_foreach_in( cmd, this )

    method on_visit( cmd:ForEachElementInRangeUpToInt )->Cmd
      scope_stack.add( cmd )
      visit( cmd.statements )
      scope_stack.remove_last
      return cmd

    method on_visit( cmd:If )->Cmd
      if (cmd.condition)
        cmd.condition = visit( cmd.condition ).require_value
        on_visit( cmd->(as ControlStructure) )
        cmd.cmd_else = visit( cmd.cmd_else )
        return cmd
      else
        return visit( Else(cmd.t,cmd.statements) )
      endIf

    method on_validate( cmd:IntToReal )->Cmd
      if local literal_int = cmd.operand->(as LiteralInt)
        return LiteralReal( cmd.operand.t, literal_int.value )
      else
        return cmd
      endIf

    method on_visit( cmd:LocalDeclarations )->Cmd
      local initialization = Statements( cmd.t )

      forEach (v in cmd.list)
        v.initial_value = visit( v.initial_value )

        if (cmd.type)
          v.type = cmd.type
        elseIf (v.initial_value)
          v.type = v.initial_value.type
          if (not v.type)
            throw cmd.t.error( "Cannot implicitly determine type from initial value." )
          endIf
        else
          throw cmd.t.error( "Local variable declarations must have an initial value assignment or an assigned ': Type'." )
        endIf

        add_local( v )

        if (v.initial_value)
          initialization.add( WriteLocal(cmd.t,v,v.initial_value.require_value) )
        else
          initialization.add( SetLocalToDefaultValue(cmd.t,v) )
        endIf

      endForEach

      return initialization

    method on_validate( cmd:LogicalNot )->Cmd
      local operand = cmd.operand.require_value
      if local literal = operand->(as LiteralLogical)
        return LiteralLogical( literal.t, not literal.value )
      endIf
      return cmd

    method on_visit( proc:Procedure )->Cmd
      temporarily this_procedure = proc
        scope_stack.add( proc )

        proc.param_count = which{ proc.parameters:proc.parameters.count || 0 }
        if (proc instanceOf Method)
          ++proc.param_count
          add_local( this_type.t, "this", this_type )
        endIf

        if (proc.parameters)
          forEach (param in proc.parameters)
            if (not param.type) throw param.t.error( "TODO: auto-store parameter" )
            if (param.initial_value) throw param.t.error( "TODO: initial parameter value" )
            param.type.resolve
            add_local( param.t, param.name, param.type )
          endForEach
        endIf

        if (proc.return_type) proc.return_type.resolve

        proc.local_count = 0
        visit_children( proc )
        scope_stack.remove_last
      endTemporarily
      return proc

    method on_visit( cmd:ReadLocal )->Cmd
      which (cmd.info.type)
        case Program.type_Int: return visit( ReadLocalInt(cmd.t,cmd.info) )
        others
          if (cmd.info.type.attributes.is_object)
            return ReadLocalObject( cmd.t, cmd.info )
          endIf
          trace
          throw cmd.t.error( "[INTERNAL] Unhandled type $ in ReadLocal."(cmd.info.type) )
      endWhich

    method on_visit( cmd:ReadLocalInt )->Cmd
      return cmd

    method on_visit( cmd:Return )->Cmd
      if (cmd.result) return visit( ReturnResult(cmd.t,cmd.result) )
      else            return cmd

    method on_validate( cmd:Unary )->Cmd
      cmd.operand.require_type
      return cmd

    method on_visit( cmd:While )->Cmd
      scope_stack.add( cmd )

      visit_children( cmd )
      cmd.condition.require_value

      scope_stack.remove_last
      return cmd

    method on_visit( cmd:WriteLocal )->Cmd
      local new_value = convert_to( visit(cmd.new_value), cmd.info.type )

      which (cmd.info.type)
        case Program.type_Int
          return WriteLocalInt( cmd.t, cmd.info, new_value )
        others
          trace cmd.info.type
          throw cmd.t.error( "[INTERNAL] Unhandled type in WriteLocal: $"(cmd.info.type) )
      endWhich

    method resolve_access( t:Token, type_context:Type, context:Cmd, name:String, args:Args, &is_constructor )->Cmd
      if (args)
        visit( args )
        (forEach in args).require_value
      endIf

      use CallCandidates
        if (is_constructor)
          type_context.collect_global_methods( "create" )
          type_context.collect_methods( "init" )
          if (CallCandidates.count == 0) return visit( CreateDefaultObject(t,type_context) )
        elseIf (context and context instanceOf TypeContext)
          type_context.collect_global_methods( name )
        else
          type_context.collect_methods( name )
          type_context.collect_global_methods( name )
        endIf

        local m = select_call_candidate( t, type_context, context, name, args, &=is_constructor )
        if (is_constructor)
          if (m.attributes.is_global)
            return visit( CallGlobalMethod(t, m, args) )
          else
            return visit( CreateObject(t, type_context, m, args) )
          endIf
        elseIf (m.attributes.is_global)
          return visit( CallGlobalMethod(t, m, args) )
        else
          return visit( CallMethod(t, context, m, args) )
        endIf
      endUse

    method select_call_candidate( t:Token, type_context:Type, context:Cmd, name:String, args:Args, &is_constructor )->Procedure
      local m = select_call_candidate( name, args )
      if (m) return m

      local call_sig = String()
      if (args)
        if (context)
          call_sig.print type_context
          call_sig.print '.'
        endIf
        call_sig.print name
        call_sig.print '('
        forEach (arg at i in args)
          if (i) call_sig.print( ',' )
          call_sig.print( arg.type )
        endForEach
        call_sig.print ')'
      else
        call_sig.print "'"
        if (context)
          call_sig.print type_context
          call_sig.print '.'
        endIf
        call_sig.print name
        call_sig.print "'"
      endIf

      local is_global = (context and context instanceOf TypeContext)
      if (CallCandidates.count)
        local message = String()
        message.println "No exact match for ambiguous call to $. Candidates:\n"(call_sig)
        forEach (m in CallCandidates)
          message.print "  "
          message.print m.type_context
          message.print '.'
          message.print m.signature
        endForEach
        throw t.error( message )
      else
        local possibilities = String[]
        if (args)
          possibilities.add( which{is_global:"global method" || "method"} )
        else
          if (context) possibilities.add( which{is_global:"global property" || "property"} )
          else         possibilities.add( "variable" )
          possibilities.add( "method" )
        endIf
        if (not context) possibilities.add( "routine" )
        if (is_constructor)
          throw t.error( "No such constructor $$ exists."(type_context,call_sig.from_first('(')) )
        elseIf (context)
          throw t.error( "No such $ $ exists."(possibilities.conjoin("or"),call_sig) )
        else
          throw t.error( "No such $ $ exists in the current scope."(possibilities.conjoin("or"),call_sig) )
        endIf
      endIf

    method select_call_candidate( name:String, args:Args )->Procedure
      local arg_count = which{ args:args.count || 0 }

      forEach (m in CallCandidates)
        if (arg_count >= m.min_args and arg_count <= m.max_args) CallCandidates.keep( m )
      endForEach

      if (CallCandidates.found_match) return CallCandidates.match
      CallCandidates.refine

      return null

endClass

augment
  METHODS
    method Cmd.resolve_assignment( t:Token, new_value:Cmd, resolver:Resolver )->Cmd
      throw t.error( "Invalid assignment." )

    method Access.resolve_assignment( t:Token, new_value:Cmd, resolver:Resolver )->Cmd
      local v = resolver.find_local( name )
      if (v) return resolver.visit( WriteLocal(t,v,new_value) )
      throw t.error( ''No such variable, method, or routine "$" exists in the current scope.''(name) )

    method Cmd.resolve_context_access( access:ContextAccess, resolver:Resolver )->Cmd
      local resolved = resolver.visit( this )
      local resolved_type = resolved.require_type
      return resolver.resolve_access( access.t, resolved_type, resolved, access.name, access.args )

    method TypeContext.resolve_context_access( access:ContextAccess, resolver:Resolver )->Cmd
      return resolver.resolve_access( access.t, require_type, this, access.name, access.args )

    method Cmd.resolve_foreach_in( cmd_foreach_in:ForEachIn, resolver:Resolver )->Cmd
      throw t.error( "TODO: resolve_foreach_in($)"(type_name) )

    method CreateRangeUpTo.resolve_foreach_in( cmd_foreach_in:ForEachIn, resolver:Resolver )->Cmd
      local type = resolver.find_compatible_type( start, limit )
      if (step_size) type = resolver.find_compatible_type( type, step_size )

      local v = Local( cmd_foreach_in.element_name.t, cmd_foreach_in.element_name->String, type )

      if (step_size)
        throw t.error( "TODO: resolve_foreach_in($) with step size"(type_name) )
      endIf

      local result = ForEachElementInRangeUpToInt( cmd_foreach_in.t, v, start, limit, cmd_foreach_in.statements )
      result.add_local( v, resolver.this_procedure )
      return resolver.visit( result )

endAugment
