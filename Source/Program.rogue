module Boss

class Program [singleton]
  PROPERTIES
    parsed_file_timestamps = [String:Timestamp]

    t              : Token
    current_module : Module
    default_module : Module
    modules        = [String:Module]

    type_Int       : Type
    type_Logical   : Type
    type_Real      : Type
    type_String    : Type

    configured     : Logical

    stack   = Variant[]
    sp      : Int

  METHODS
    method init
      Program = this

    method configure
      t = Token( TokenType.IDENTIFIER, "[INTERNAL]", &content="Boss" )
      default_module = Module( t, "Boss" )
      current_module = default_module

      type_Int     = Type( t, "Int" )
      type_Logical = Type( t, "Logical" )
      type_Real    = Type( t, "Real" )
      type_String  = Type( t, "String" )

    method execute( cmd:Cmd )
      temporarily Program = this
        cmd.execute
      endTemporarily

    method launch
      resolve

      forEach (mod in modules)
        mod.launch
      endForEach

    method parse( file:File )->CompileError
      temporarily Program = this
        file .= abs

        local timestamp = file.timestamp
        local entry = parsed_file_timestamps.find( file.filepath )
        if (entry and entry.value >= timestamp) return null

        local err = parse( file.filepath, String(file) )
        if (err) return err

        parsed_file_timestamps[ file.filepath ] = timestamp
        return null
      endTemporarily

    method parse( filepath:String, source:String, timestamp=Timestamp():Timestamp )->CompileError
      try
        local parser = Parser( File(filepath) )
        if (not configured) configure

        temporarily Program=this, current_module=default_module
          local elements = parser.parse
          (forEach in elements).store
        endTemporarily

      catch (err:CompileError)
        return err
      catch (err:Error)
        return CompileError( "[INTERNAL ERROR] " + err, filepath )
      endTry

    method resolve
      (forEach in modules).resolve
endClass
