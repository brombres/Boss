module Boss

class Program [singleton]
  PROPERTIES
    t              : Token
    default_module : Module
    current_module : Module
    modules        = [String:Module]
    types          = [String:Type]  # All types, fully qualified e.g. Boss::Int

    type_Int       : Type
    type_Logical   : Type
    type_Real      : Type
    type_String    : Type

    pending_elements = ProgramElements[]

  METHODS
    method init
      _configure

    method init( elements:ProgramElements[] )
      _configure
      add( elements )

    method add( elements:ProgramElements[] )
      pending_elements.add( elements )

    method execute( cmd:Cmd )->Variant
      temporarily Program = this
        return cmd.execute
      endTemporarily

    method get_module( t:Token, module_name:String )->Module
      local mod = modules[module_name]
      if (not mod)
        mod = Module( t, module_name )
        modules[module_name] = mod
      endIf
      return mod

    method launch
      temporarily Program = this
        forEach (mod in modules)
          mod.launch
        endForEach
      endTemporarily

    method organize
      temporarily Program=this, current_module=default_module
        CollectTypes.visit( forEach in pending_elements )

        forEach (type_name in BossVM.native_types)
          local type = Program.default_module.type( BossVM.t, type_name )
          type.attributes.is_native_type = true
          trace type.scoped_name
        endForEach

        forEach (entry in BossVM.native_methods.entries)
          local sig = Parser(
          "[BossVM.register_method($)]"(entry.key),
            entry.key
          ).parse( ParserCore.ip_native_procedure_signature )->(as NativeProcedureSignature)
          local type = Program.default_module.must_find_type( sig.t, sig.scoped_type_name )
          if (sig instanceOf NativeGlobalMethodSignature)
            local m = GlobalMethod( sig.t, sig.name ).[ cmd_call=entry.value ]
            if (sig.parameters.count)
              ensure<<m.parameters>>( sig.t )
              forEach (param at i in sig.parameters)
                m.parameters.add( Local(param.t,"arg"+(i+1),param.type).[initial_value=param.default_value] )
              endForEach
            endIf
            m.return_type = sig.return_type
            m.statements.add( entry.value.cloned )
            type.add( m )
          else
            local m = Method( sig.t, sig.name ).[ cmd_call=entry.value ]
            if (sig.parameters.count)
              ensure<<m.parameters>>( sig.t )
              forEach (param at i in sig.parameters)
                m.parameters.add( Local(param.t,"arg"+(i+1),param.type).[initial_value=param.default_value] )
              endForEach
            endIf
            m.return_type = sig.return_type
            m.statements.add( entry.value.cloned )
            type.add( m )
          endIf
        endForEach

        forEach (elements in pending_elements)
          (forEach in elements.cloned).store
        endForEach

        (forEach in modules).organize

        Organizer.organize_program

        pending_elements.clear
      endTemporarily

    method resolve
      temporarily Program = this
        Resolver.resolve_program
      endTemporarily

    method _configure
      temporarily Program = this
        t = Token( TokenType.IDENTIFIER, "[Boss]", &content="Boss" )
        default_module = Module( t, "Boss" )

        type_Int     = default_module.define_type( t, "Int",     Attribute.PRIMITIVE )
        type_Logical = default_module.define_type( t, "Logical", Attribute.PRIMITIVE )
        type_Real    = default_module.define_type( t, "Real",    Attribute.PRIMITIVE )
        type_String  = default_module.define_type( t, "String",  Attribute.PRIMITIVE )
      endTemporarily

endClass
