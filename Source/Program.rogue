module RogueScript

class Program [singleton]
  PROPERTIES
    t              : Token
    default_module : Module
    current_module : Module
    modules        = [String:Module]
    types          = [String:Type]  # All types, fully qualified e.g. RogueScript::Int

    type_Int       : Type
    type_Logical   : Type
    type_Real      : Type
    type_String    : Type

    pending_elements = ProgramElements[]

  METHODS
    method init
      _configure

    method init( elements:ProgramElements[] )
      _configure
      add( elements )

    method add( elements:ProgramElements[] )
      pending_elements.add( elements )

    method execute( cmd:Cmd )->Variant
      temporarily Program = this
        return cmd.execute
      endTemporarily

    method get_module( t:Token, module_name:String )->Module
      local mod = modules[module_name]
      if (not mod)
        mod = Module( t, module_name )
        modules[module_name] = mod
      endIf
      return mod

    method launch
      temporarily Program = this
        forEach (mod in modules)
          mod.launch
        endForEach
      endTemporarily

    method organize
      temporarily Program=this, current_module=default_module
        CollectTypes.visit( forEach in pending_elements )

        forEach (entry in RogueScriptVM.native_types.entries)
          local type = Program.default_module.type( RogueScriptVM.t, entry.key )
          type.attributes.is_native_type = true
          type.native_instance_of   = entry.value.instance_of
          type.native_get_singleton = entry.value.get_singleton
          type.native_set_singleton = entry.value.set_singleton
          type.attributes.is_singleton = (type.native_get_singleton or type.native_set_singleton)
        endForEach

        forEach (entry in RogueScriptVM.native_constructors.entries)
          local sig = Parser(
            "[RogueScriptVM.register_constructor($)]"(entry.key),
            entry.key
          ).parse( ParserCore.ip_native_constructor_signature )->(as NativeConstructorSignature)
          local type = Program.default_module.must_find_type( sig.t, sig.scoped_type_name )
          local m = GlobalMethod( sig.t, "create" ).[ cmd_call=entry.value ]
          if (sig.parameters.count)
            ensure<<m.parameters>>( sig.t )
            forEach (param at i in sig.parameters)
              m.parameters.add( Local(param.t,"arg"+(i+1),param.type).[initial_value=param.default_value] )
            endForEach
          endIf
          m.return_type = type
          m.statements.add( entry.value.cloned )
          type.add( m )
        endForEach

        forEach (entry in RogueScriptVM.native_global_methods.entries)
          local sig = Parser(
            "[RogueScriptVM.register_global_method($)]"(entry.key),
            entry.key
          ).parse( ParserCore.ip_native_method_signature )->(as NativeMethodSignature)
          local type = Program.default_module.must_find_type( sig.t, sig.scoped_type_name )
          local m = GlobalMethod( sig.t, sig.name ).[ cmd_call=entry.value ]
          if (sig.parameters.count)
            ensure<<m.parameters>>( sig.t )
            forEach (param at i in sig.parameters)
              m.parameters.add( Local(param.t,"arg"+(i+1),param.type).[initial_value=param.default_value] )
            endForEach
          endIf
          m.return_type = sig.return_type
          m.statements.add( entry.value.cloned )
          type.add( m )
        endForEach

        forEach (entry in RogueScriptVM.native_methods.entries)
          local sig = Parser(
            "[RogueScriptVM.register_method($)]"(entry.key),
            entry.key
          ).parse( ParserCore.ip_native_method_signature )->(as NativeMethodSignature)
          local type = Program.default_module.must_find_type( sig.t, sig.scoped_type_name )
          local m = Method( sig.t, sig.name ).[ cmd_call=entry.value ]
          if (sig.parameters.count)
            ensure<<m.parameters>>( sig.t )
            forEach (param at i in sig.parameters)
              m.parameters.add( Local(param.t,"arg"+(i+1),param.type).[initial_value=param.default_value] )
            endForEach
          endIf
          m.return_type = sig.return_type
          m.statements.add( entry.value.cloned )
          type.add( m )
        endForEach

        forEach (elements in pending_elements)
          (forEach in elements.cloned).store
        endForEach

        (forEach in modules).organize

        Organizer.organize_program

        pending_elements.clear
      endTemporarily

    method resolve
      temporarily Program = this
        Resolver.resolve_program
      endTemporarily

    method _configure
      temporarily Program = this
        t = Token( TokenType.IDENTIFIER, "[RogueScript]", &content="RogueScript" )
        default_module = Module( t, "RogueScript" )

        type_Int     = default_module.define_type( t, "Int",     Attribute.PRIMITIVE )
        type_Logical = default_module.define_type( t, "Logical", Attribute.PRIMITIVE )
        type_Real    = default_module.define_type( t, "Real",    Attribute.PRIMITIVE )
        type_String  = default_module.define_type( t, "String",  Attribute.PRIMITIVE )
      endTemporarily

endClass
