module Boss

class Module
  GLOBAL METHODS
    method create( t:Token, name:String )->Module
      local mod = Program.modules[ name ]
      if (mod) return mod

      mod = Module( t, name, &initializer )
      Program.modules[ name ] = mod
      return mod

  PROPERTIES
    t                 : Token
    name              : String

    global_statements : Statements
    m_on_launch       : GlobalMethod

    used_modules      = [String:Module]
    types             = [String:Type]

    visiting          : Logical

  METHODS
    method init( t, name, initializer:Logical )
      use_module( t, "Boss" )

    method define_type( def:Class )->Type
      return define_type( def.t, def.name->String, def.attributes.cloned ).[ definition=def ]

    method define_type( t:Token, type_name:String, attributes:Attributes )->Type
      if (types.contains(type_name))
        throw t.error( "Type $::$ is already defined."(name,type_name) )
      endIf

      local type = Type( t, this, type_name, attributes )
      types[type_name] = type
      Program.types[type.scoped_name] = type
      return type

    method define_type( t:Token, type_name:String, attribute_flags:Int )->Type
      return define_type( t, type_name, Attributes(t,attribute_flags) )

    method find_type( type_name:String, &limited )->Type
      if (visiting) return null

      if (type_name.contains("::"))
        # Name is qualified with module name
        return Program.types[type_name]
      endIf

      local result = types[type_name]
      if (result) return result

      if (limited) return null

      temporarily visiting = true
        forEach (mod in used_modules)
          result = mod.find_type( type_name )
          if (result) return result
        endForEach
        return null
      endTemporarily

    method launch
      if (m_on_launch)
        Program.execute( m_on_launch )
      endIf

    method must_find_type( t:Token, type_name:String, &limited )->Type
      local result = find_type( type_name, &=limited )
      if (result) return result
      throw t.error( "Reference to undefined type $."(type_name) )

    method organize
      if (global_statements)
        if (m_on_launch)
          m_on_launch.statements.add( forEach in global_statements )
        else
          m_on_launch = GlobalMethod( t, "on_launch", &statements=global_statements )
          type( t, "Routine" ).add( m_on_launch )
        endIf
        global_statements = null
      endIf

    method to->String
      return name

    method type( t:Token, name:String, attribute_flags=Attribute.OBJECT:Int )->Type
      if (name.contains("::"))
        return Program.get_module( t, name.before_last("::") ).type( t, name.after_last("::"), &=attribute_flags )
      endIf

      local result = types[name]
      if (result) return result

      return define_type( t, name, attribute_flags )

    method type_Routine->Type
      return type( t, "Routine" )

    method use_module( t:Token, name:String )
      if (name == this.name) return
      if (used_modules.contains(name)) return

      local mod = Program.modules[name]
      if (not mod)
        mod = Module( t, name )
        Program.modules[name] = mod
      endIf
      used_modules[ name ] = mod

    method validate_type( type:Type )->Type
      if (not type or type.module_context) return type
      return must_find_type( type.t, type.name )
endClass
