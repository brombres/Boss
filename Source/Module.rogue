module Boss

class Module
  GLOBAL METHODS
    method create( t:Token, name:String )->Module
      local mod = Program.modules[ name ]
      if (mod) return mod

      mod = Module( t, name, &initializer )
      Program.modules[ name ] = mod
      return mod

  PROPERTIES
    t                 : Token
    name              : String

    launch_statements : Statements
    m_on_launch       : GlobalMethod

    used_modules      = [String:Module]
    types             = [String:Type]

    visiting          : Logical

  METHODS
    method init( t, name, initializer:Logical )

    method define_type( def:Class )
      local type_name = def.name->String
      if (types.contains(type_name))
        throw def.t.error( "Type $::$ is already defined."(name,type_name) )
      endIf

      local type = Type( this, def )
      types[type_name] = type

    method find_type( type_name:String )->Type
      if (visiting) return null

      if local i = type_name.locate( "::" )
        # Name is qualified with module name
        local mod_name = type_name.leftmost( i )
        type_name = type_name.unleft( i+2 )
        if (mod_name == this.name) return types[type_name]
        local mod = Program.modules[mod_name]
        if (not mod) return null
        return mod.types[type_name]
      endIf

      local result = types[type_name]
      if (result) return result

      temporarily visiting = true
        forEach (mod in used_modules)
          result = mod.find_type( type_name )
          if (result) return result
        endForEach
        return null
      endTemporarily

    method launch
      if (m_on_launch)
        Program.execute( m_on_launch )
      endIf

    method must_find_type( t:Token, type_name:String )->Type
      local result = find_type( type_name )
      if (result) return result
      throw t.error( "Reference to undefined type $."(type_name) )

    method organize
      if (launch_statements)
        m_on_launch = GlobalMethod( t, "on_launch", &statements=launch_statements )
        type( t, "Routine" ).add( m_on_launch )
        launch_statements = null
      endIf

      (forEach in types).organize

    method resolve( resolver:Resolver )
      temporarily resolver.this_module = this
        (forEach in types).resolve( resolver )
      endTemporarily

    method to->String
      return name

    method type( t:Token, name:String )->Type
      trace
      throw t.error( "TODO" )
      #local result = find_type( name )
      #if (result) return result

      #result = Type( t, this, name )
      #types[ name ] = result
      #return result

    method type_Routine->Type
      return type( t, "Routine" )

    method use_module( t:Token, name:String )
      if (name == this.name) return
      if (used_modules.contains(name)) return

      local mod = Program.modules[ name ]
      if (not mod) mod = Module( t, name )
      used_modules[ name ] = mod
endClass
