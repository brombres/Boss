module RogueScript

uses Geometry [export]

$include VM/Attributes
$include VM/RogueScriptObject
$include VM/CallCandidates
$include VM/CmdExecute
$include VM/CmdPreprocess
$include VM/CmdStore
$include VM/CmdType
$include VM/CollectTypes
$include VM/Module
$include VM/NativeTypeInfo
$include VM/Organizer
$include VM/Parser        [optional]
$include VM/Procedure
$include VM/Program
$include VM/Resolver
$include VM/Scanner
$include VM/Type
$include VM/VM

class VM [singleton]
  PROPERTIES
    t                 = Token( TokenType.IDENTIFIER, "[RogueScript]", &content="RogueScript" )
    new_elements      : [String:ProgramElements]
    resolved_elements : [String:ProgramElements]

    native_types          = [String:NativeTypeInfo]
    native_constructors   = [String:Cmd]
    native_global_methods = [String:Cmd]
    native_methods        = [String:Cmd]

    program : Program
    stack   = Variant[]
    fp      : Int

  METHODS # Runtime
    method context->Variant
      return stack[fp]

    method int( index:Int )->Int
      return stack[fp+index]->Int

    method logical( index:Int )->Int
      return stack[fp+index]?

    method parameter( index:Int )->Variant
      # First parameter is index 1.
      return stack[fp+index]

    method real( index:Int )->Real
      return stack[fp+index]->Real

    method xy( index:Int )->XY
      return stack[fp+index]->XY

  METHODS # Configuration
    method deregister_constructor( signature:String )
      if (native_constructors.remove(signature)) .begin_staging

    method deregister_global_method( full_signature:String )
      if (native_global_methods.remove(full_signature)) .begin_staging

    method deregister_method( full_signature:String )
      if (native_methods.remove(full_signature)) .begin_staging

    method deregister_type( scoped_name:String )
      if (native_types.remove(scoped_name)) .begin_staging

    method execute( script:String )->Variant
      local error = launch
      if (error) throw error

      temporarily VM=this, Program=program
        local statements = Parser( "[EXECUTE]", script ).parse( Parser.ip_multi_line_statements )->(as Statements)
        local m_execute = GlobalMethod( statements.t, "execute", &statements=statements )
        m_execute.type_context = Program.default_module.type( Program.default_module.t, "Routine" )
        Resolver.resolve( m_execute )
        return Program.execute( m_execute )
      endTemporarily

    method include( file:File )->RogueScriptError
      # Loads file if not already loaded.
      file = .find_file( file )
      local filepath = file.filepath
      if (new_elements and new_elements.contains(filepath)) return null
      return load( file )

    method launch->RogueScriptError
      try
        temporarily VM = this
          if (new_elements and new_elements.count)
            local staged_program = Program( new_elements.values )
            resolved_elements = new_elements
            new_elements = null
            staged_program.organize
            staged_program.resolve
            staged_program.launch
            program = staged_program
          elseIf (not program)
            program = Program()
            program.organize
            program.resolve
            program.launch
          endIf
        endTemporarily
      catch (error:RogueScriptError)
        new_elements = null
        return error
      catch (error:Exception)
        new_elements = null
        return CompileError( "[INTERNAL ERROR] " + error )
      endTry

      return null

    method load( file:File )->RogueScriptError
      file = .find_file( file )
      local filepath = file.filepath

      .begin_staging

      try
        temporarily VM = this
          local elements = Parser( File(filepath) ).parse->(as ProgramElements)
          new_elements[filepath] = elements
          (forEach in elements).preprocess
        endTemporarily

      catch (error:RogueScriptError)
        new_elements = null
        return error
      catch (error:Exception)
        new_elements = null
        return CompileError( "[INTERNAL ERROR] " + error, file.filepath )
      endTry

      return null

    method register_constructor( signature:String, cmd:Cmd )
      native_constructors[signature] = cmd
      .begin_staging

    method register_constructor( full_signature:String, callback:Function()->Variant )
      register_constructor( full_signature, CallNativeMethod(t,callback) )

    method register_global_method( full_signature:String, cmd:Cmd )
      native_global_methods[full_signature] = cmd
      .begin_staging

    method register_global_method( full_signature:String, callback:Function()->Variant )
      register_global_method( full_signature, CallNativeMethod(t,callback) )

    method register_method( full_signature:String, cmd:Cmd )
      native_methods[full_signature] = cmd
      .begin_staging

    method register_method( full_signature:String, callback:Function()->Variant )
      register_method( full_signature, CallNativeMethod(t,callback) )

    method register_type(
        scoped_name:String,
        instance_of:Function(Variant)->Logical,
        get_singleton=null:Function()->Variant,
        set_singleton=null:Function(Variant),
        variant_type=Variant.TYPE_OBJECT:Int
      )
      native_types[scoped_name] = NativeTypeInfo( instance_of, get_singleton, set_singleton, variant_type )

    method unload( file:File )
      .begin_staging

      local filepath = file.abs.filepath
      new_elements.remove( filepath )
      resolved_elements?.remove( filepath )

    method update->RogueScriptError
      try
        local error = launch
        if (error) return error

      catch (error:RogueScriptError)
        new_elements = null
        return error
      catch (error:Exception)
        new_elements = null
        return CompileError( "[INTERNAL ERROR] " + error )
      endTry

      return null

    method .begin_staging
      if (not new_elements)
        if (resolved_elements)
          new_elements = resolved_elements.cloned
        else
          new_elements = [String:ProgramElements]
        endIf
      endIf

    method .find_file( file:File )->File
      file .= with_extension( ".rogue" )
      return file.abs

endClass
