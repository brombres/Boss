module RogueScript

class Type : Cmd
  PROPERTIES
    batch_id             : Int

    module_context       : Module
    definition           : Class

    attributes           : Attributes
    base_class           : Type
    aspects              : Type[]

    name                 : String
    scoped_name          : String
    element_type         : Type
    is_optional_type     : Logical
    native_instance_of   : Function(Variant)->Logical
    native_get_singleton : Function()->Variant
    native_set_singleton : Function(Variant)
    variant_type         = Variant.TYPE_OBJECT : Int

    global_methods         = [String:GlobalMethod]
    global_methods_by_name = [String:GlobalMethod[]]
    methods                = [String:Method]
    methods_by_name        = [String:Method[]]
    definitions            = [String:Cmd]

    visiting  : Logical
    resolved  : Logical

  METHODS
    method init( t, name )

    method init( t, element_type )

    method init( t, element_type, is_optional_type )

    method init( t, module_context, name, attributes )
      if (not attributes.classification) attributes.is_object = true

    method init( existing:Type )
      prior.init( existing )
      name = existing.name
      if (existing.element_type) element_type = existing.element_type.cloned
      is_optional_type = existing.is_optional_type

    method init_object
      batch_id = Parser.current_batch_id

    method add( m:GlobalMethod )
      if (not m.type_context) m.type_context = this
      m.organize

      block existing_m = global_methods[ m.signature ]
        if (existing_m and existing_m.type_context is m.type_context)
          local m_type = which{ name=="Routine":"routine " || "global method $."(this) }
          throw m.t.error( "A $$ already exists."(m_type,m.signature) )
        endIf
      endBlock

      block existing_m = methods[ m.signature ]
        if (existing_m and existing_m.type_context is m.type_context)
          throw m.t.error( "A method $.$ already exists."(this,m.signature) )
        endIf
      endBlock

      if (m.name == "create")
        if (not m.return_type or m.return_type is not this)
          throw m.t.error( "A $ create() constructor must have return-type $."(this,this) )
        endIf
      elseIf (m.name == "init")
        throw m.t.error( "A $ init() constructor cannot be a global method."(this) )
      endIf

      global_methods[m.signature] = m
      if (not global_methods_by_name.contains(m.name))
        global_methods_by_name[m.name] = GlobalMethod[]
      endIf
      global_methods_by_name[m.name].add( m )

    method add( m:Method )
      if (not m.type_context) m.type_context = this
      m.organize

      block existing_m = global_methods[ m.signature ]
        if (existing_m)
          throw m.t.error( "A global method $.$ already exists."(this,m.signature) )
        endIf
      endBlock

      block existing_m = methods[ m.signature ]
        if (existing_m and existing_m.type_context is m.type_context)
          throw m.t.error( "A method $.$ already exists."(this,m.signature) )
        endIf
      endBlock

      if (m.name == "init")
        if (m.return_type)
          throw m.t.error( "A $ init() constructor cannot have a return-type."(this) )
        endIf
      elseIf (m.name == "create")
        throw m.t.error( "A $ create() constructor must be a global method."(this) )
      endIf

      methods[m.signature] = m
      if (not methods_by_name.contains(m.name))
        methods_by_name[m.name] = Method[]
      endIf
      methods_by_name[m.name].add( m )

    method collect_base_types
      if (not definition) return

      forEach (base_type in definition.base_types)
        base_type = module_context.must_find_type( base_type.t, base_type.name )
        if (base_type.attributes.is_aspect)
          ensure<<aspects>>
          aspects.add( base_type )
        elseIf (base_type.attributes.is_object == this.attributes.is_object)
          base_class = base_type
        else
          throw t.error( "[INTERNAL] Unhandled type attributes for base type " + base_type )
        endIf
      endForEach

    method collect_global_methods( method_name:String )
      local methods = global_methods_by_name[ method_name ]
      if (methods) CallCandidates.add( forEach in methods )

    method collect_methods( method_name:String )
      local methods = methods_by_name[ method_name ]
      if (methods) CallCandidates.add( forEach in methods )

    method description->String
      return name

    method resolve
      if (resolved) return
      resolved = true
      Resolver.resolve_type( this )

    method scoped_name->String
      if (@scoped_name) return @scoped_name
      @scoped_name = "$::$"(module_context,name)
      return @scoped_name

    method to->String
      return name

    method validate_type_hierarchy
      validate_type_hierarchy( this )

    method validate_type_hierarchy( extended_type:Type )
      contingent
        visiting = true
        if (base_class)
          sufficient (base_class is this)
          necessary (not base_class.visiting)
          base_class.validate_type_hierarchy( extended_type )
        endIf
        if (aspects)
          forEach (a in aspects)
            sufficient (a is this)
            necessary (not a.visiting)
            a.validate_type_hierarchy( extended_type )
          endForEach
        endIf
        visiting = false
        return

      satisfied
        throw t.error( "Circular class extension - class $ cannot extend itself."(name) )

      unsatisfied
        local a_name = extended_type.name
        local b_name = name
        if (module_context is not extended_type.module_context)
          a_name = extended_type.scoped_name
          b_name = scoped_name
        endIf
        throw t.error( "Circular class extension - class $ already extends $."(a_name,b_name) )

      endContingent

endClass

