module RogueScript

class RogueScriptVM [singleton]
  PROPERTIES
    t                 = Token( TokenType.IDENTIFIER, "[RogueScript]", &content="RogueScript" )
    new_elements      : [String:ProgramElements]
    resolved_elements : [String:ProgramElements]

    native_types          = [String:NativeTypeInfo]
    native_constructors   = [String:Cmd]
    native_global_methods = [String:Cmd]
    native_methods        = [String:Cmd]

    program : Program
    stack   = Variant[]
    fp      : Int

  METHODS
    method context->Variant
      return stack[fp]

    method deregister_constructor( signature:String )
      if (native_constructors.remove(signature)) _begin_staging

    method deregister_global_method( full_signature:String )
      if (native_global_methods.remove(full_signature)) _begin_staging

    method deregister_method( full_signature:String )
      if (native_methods.remove(full_signature)) _begin_staging

    method deregister_type( scoped_name:String )
      if (native_types.remove(scoped_name)) _begin_staging

    method execute( script:String )->Variant
      local error = launch
      if (error) throw error

      temporarily RogueScriptVM=this, Program=program
        local statements = Parser( "[EXECUTE]", script ).parse( Parser.ip_multi_line_statements )->(as Statements)
        local m_execute = GlobalMethod( statements.t, "execute", &statements=statements )
        m_execute.type_context = Program.default_module.type( Program.default_module.t, "Routine" )
        Resolver.resolve( m_execute )
        return Program.execute( m_execute )
      endTemporarily

    method include( file:File )->RogueScriptError
      # Loads file if not already loaded.
      file = _find_file( file )
      local filepath = file.filepath
      if (new_elements and new_elements.contains(filepath)) return null
      return load( file )

    method launch->RogueScriptError
      try
        temporarily RogueScriptVM = this
          if (new_elements and new_elements.count)
            local staged_program = Program( new_elements.values )
            resolved_elements = new_elements
            new_elements = null
            staged_program.organize
            staged_program.resolve
            staged_program.launch
            program = staged_program
          elseIf (not program)
            program = Program()
            program.organize
            program.resolve
            program.launch
          endIf
        endTemporarily
      catch (error:RogueScriptError)
        new_elements = null
        return error
      catch (error:Exception)
        new_elements = null
        return CompileError( "[INTERNAL ERROR] " + error )
      endTry

      return null

    method load( file:File )->RogueScriptError
      file = _find_file( file )
      local filepath = file.filepath

      _begin_staging

      try
        temporarily RogueScriptVM = this
          local elements = Parser( File(filepath) ).parse->(as ProgramElements)
          new_elements[filepath] = elements
          (forEach in elements).preprocess
        endTemporarily

      catch (error:RogueScriptError)
        new_elements = null
        return error
      catch (error:Exception)
        new_elements = null
        return CompileError( "[INTERNAL ERROR] " + error, file.filepath )
      endTry

      return null

    method register_constructor( signature:String, cmd:Cmd )
      native_constructors[signature] = cmd
      _begin_staging

    method register_constructor( full_signature:String, callback:Function()->Variant )
      register_constructor( full_signature, CallNativeMethod(t,callback) )

    method register_global_method( full_signature:String, cmd:Cmd )
      native_global_methods[full_signature] = cmd
      _begin_staging

    method register_global_method( full_signature:String, callback:Function()->Variant )
      register_global_method( full_signature, CallNativeMethod(t,callback) )

    method register_method( full_signature:String, cmd:Cmd )
      native_methods[full_signature] = cmd
      _begin_staging

    method register_method( full_signature:String, callback:Function()->Variant )
      register_method( full_signature, CallNativeMethod(t,callback) )

    method register_type(
        scoped_name:String,
        instance_of:Function(Object)->Logical,
        get_singleton=null:Function()->Variant,
        set_singleton=null:Function(Variant)
      )
      native_types[scoped_name] = NativeTypeInfo( instance_of, get_singleton, set_singleton )

    method unload( file:File )
      _begin_staging

      local filepath = file.abs.filepath
      new_elements.remove( filepath )
      resolved_elements?.remove( filepath )

    method update->RogueScriptError
      try
        local error = launch
        if (error) return error

      catch (error:RogueScriptError)
        new_elements = null
        return error
      catch (error:Exception)
        new_elements = null
        return CompileError( "[INTERNAL ERROR] " + error )
      endTry

      return null

    method _begin_staging
      if (not new_elements)
        if (resolved_elements)
          new_elements = resolved_elements.cloned
        else
          new_elements = [String:ProgramElements]
        endIf
      endIf

    method _find_file( file:File )->File
      file .= with_extension( ".rogue" )
      return file.abs

endClass
