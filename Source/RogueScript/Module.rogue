module RogueScript

class Module
  GLOBAL METHODS
    method create( t:Token, name:String )->Module
      local mod = Program.modules[ name ]
      if (mod) return mod

      mod = Module( t, name, &initializer )
      Program.modules[ name ] = mod
      return mod

  PROPERTIES
    t                 : Token
    name              : String

    global_statements : Statements
    m_on_launch       : GlobalMethod

    used_modules      = [String:Module]
    types             = [String:Type]

    visiting          : Logical

  METHODS
    method init( t, name, initializer:Logical )
      Program.modules[name] = this
      use_module( t, "Rogue" )

    method define_type( def:Class )->Type
      return define_type( def.t, def.name->String, def.attributes.cloned ).[ t=t, definition=def ]

    method define_type( t:Token, type_name:String, attributes:Attributes )->Type
      local type = types[type_name]

      if (type)
        if (type.definition)
          throw t.error( "Type $::$ is already defined."(name,type_name) )
        endIf
        type.attributes.flags |= attributes.flags
        type.attributes.add( forEach in attributes )
      else
        type = Type( t, this, type_name, attributes )
        types[type_name] = type
        Program.types[type.scoped_name] = type
      endIf

      if (this is Program.default_module)
        if (type.attributes.is_primitive)
          which (type_name)
            case "Byte":      type.variant_type = Variant.TYPE_BYTE
            case "Character": type.variant_type = Variant.TYPE_CHARACTER
            case "Int":       type.variant_type = Variant.TYPE_INT
            case "Int32":     type.variant_type = Variant.TYPE_INT32
            case "Int64":     type.variant_type = Variant.TYPE_INT64
            case "Real":      type.variant_type = Variant.TYPE_REAL
            case "Real32":    type.variant_type = Variant.TYPE_REAL32
            case "Real64":    type.variant_type = Variant.TYPE_REAL64
            case "Logical":   type.variant_type = Variant.TYPE_LOGICAL
          endWhich
        endIf
      endIf

      return type

    method define_type( t:Token, type_name:String, attribute_flags:Int )->Type
      return define_type( t, type_name, Attributes(t,attribute_flags) )

    method find_type( type_name:String, &limited )->Type
      if (visiting) return null

      if (type_name.contains("::"))
        # Name is qualified with module name
        return Program.types[type_name]
      endIf

      local result = types[type_name]
      if (result) return result

      if (limited) return null

      temporarily visiting = true
        forEach (mod in used_modules)
          result = mod.find_type( type_name )
          if (result) return result
        endForEach
        return null
      endTemporarily

    method launch
      if (m_on_launch)
trace m_on_launch.statements
        VM.stack.add( Variant() )
        Program.execute( m_on_launch )
      endIf

    method must_find_type( t:Token, type_name:String, &limited )->Type
      local result = find_type( type_name, &=limited )
      if (result) return result
      throw t.error( "Reference to undefined type $."(type_name) )

    method must_find_type( type:Type )->Type
      return must_find_type( type.t, type.name )

    method organize
      if (global_statements)
        if (m_on_launch)
          m_on_launch.statements.add( forEach in global_statements )
        else
          m_on_launch = GlobalMethod( t, "on_launch", &statements=global_statements )
          type( t, "Routine" ).add_global_method( m_on_launch )
        endIf
        global_statements = null
      endIf

    method to->String
      return name

    method type( t:Token, name:String, attribute_flags=Attribute.OBJECT:Int )->Type
      if (name.contains("::"))
        return Program.get_module( t, name.before_last("::") ).type( t, name.after_last("::"), &=attribute_flags )
      endIf

      local result = types[name]
      if (result) return result

      return define_type( t, name, attribute_flags )

    method type_Routine->Type
      return type( t, "Routine" )

    method use_module( t:Token, name:String )
      if (name == this.name) return
      if (used_modules.contains(name)) return

      local mod = Program.modules[name]
      if (not mod)
        mod = Module( t, name )
      endIf
      used_modules[ name ] = mod

    method validate_type( type:Type )->Type
      if (not type or type.module_context) return type
      return must_find_type( type.t, type.name )
endClass
