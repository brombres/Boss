module RogueScript

class VM [singleton]
  PROPERTIES
    t                 = Token( TokenType.IDENTIFIER, "[RogueScript]", &content="RogueScript" )
    new_elements      : [String:ProgramElements]
    resolved_elements : [String:ProgramElements]
    include_folders   = Set<<String>>().[ add("") ]

    native_types          = [String:NativeTypeInfo]
    native_constructors   = [String:Cmd]
    native_global_methods = [String:Cmd]
    native_methods        = [String:Cmd]

    program : Program
    stack   = Variant[]
    fp      : Int

    resolve_filepath = (filepath) => filepath : Function(String)->String

  METHODS # External runtime API
    method compile( script:String )->(Function->Variant)
      launch

      temporarily VM=this, Program=program
        local statements = Parser( "[EXECUTE]", script ).parse( Parser.ip_multi_line_statements )->(as Statements)
        local m_execute = GlobalMethod( statements.t, "execute", &statements=statements )
        m_execute.type_context = Program.default_module.type( Program.default_module.t, "Routine" )
        Resolver.resolve( m_execute )
        return function()->Variant with (vm=this)
          temporarily VM=vm, Program=program
            return program.execute( m_execute )
          endTemporarily
        endFunction
      endTemporarily

    method execute( script:String )->Variant
      return compile(script)()

  METHODS # Internal runtime API
    method context->Variant
      return stack[fp]

    method int( index:Int )->Int
      return stack[fp+index]->Int

    method logical( index:Int )->Int
      return stack[fp+index]?

    method call_method( context:Variant, m:Procedure, args=null:Args )->Variant
      local old_stack_count = stack.count
      stack.add( context )

      if (args and args.count) stack.add( (forEach in args).execute )

      local result = m.execute
      stack.discard_from( old_stack_count )
      return result

    method create_object( of_type:Type, &no_init )->Variant
      local obj = Variant( Object(of_type) )
      if (of_type.m_init_object) call_method( obj, of_type.m_init_object )
      if (not no_init and of_type.m_init) call_method( obj, of_type.m_init )
      return obj

    method create_object( of_type:Type, m_init:Procedure, args:Args )->Variant
      local obj = Variant( Object(of_type) )
      call_method( obj, m_init, args )
      return obj

    method parameter( index:Int )->Variant
      # First parameter is index 1.
      return stack[fp+index]

    method real( index:Int )->Real
      return stack[fp+index]->Real

    method string( index:Int )->String
      return stack[fp+index]->String

    method xy( index:Int )->XY
      return stack[fp+index]->XY

  METHODS # Configuration
    method deregister_constructor( signature:String )
      if (native_constructors.remove(signature)) .begin_staging

    method deregister_global_method( full_signature:String )
      if (native_global_methods.remove(full_signature)) .begin_staging

    method deregister_method( full_signature:String )
      if (native_methods.remove(full_signature)) .begin_staging

    method deregister_type( scoped_name:String )
      if (native_types.remove(scoped_name)) .begin_staging

    method include( file:File, &suppress_error )->Logical
      # Loads file if not already loaded.
      if local found_file = .find_file( file )
        local filepath = found_file.filepath
        if (new_elements and new_elements.contains(filepath)) return true
        return load( found_file, &=suppress_error )
      else
        if (suppress_error) return false
        throw CompileError( "File not found: $"(file) )
      endIf

    method launch
      try
        temporarily VM = this
          if (new_elements and new_elements.count)
            local staged_program = Program( new_elements.values )
            resolved_elements = new_elements
            new_elements = null
            staged_program.organize
            staged_program.resolve
            staged_program.launch
            program = staged_program
          elseIf (not program)
            program = Program()
            program.organize
            program.resolve
            program.launch
          endIf
        endTemporarily
      catch (error:Exception)
        new_elements = null
        throw error
      endTry

    method load( file:File, &suppress_error )->Logical
      if local found_file = .find_file( file )
        file = found_file
      else
        if (suppress_error) return false
        throw RogueScriptError( "File not found: " + file )
      endIf

      local filepath = file.filepath

      .begin_staging

      try
        temporarily VM = this
          local elements = Parser( File(filepath) ).parse->(as ProgramElements)
          new_elements[filepath] = elements
          (forEach in elements).preprocess
        endTemporarily

      catch (error:Exception)
        new_elements = null
        if (suppress_error) return false
        throw error

      endTry

      return true

    method register_constructor( signature:String, cmd:Cmd )
      native_constructors[signature] = cmd
      .begin_staging

    method register_constructor( full_signature:String, callback:Function()->Variant )
      register_constructor( full_signature, CallNativeMethod(t,callback) )

    method register_global_method( full_signature:String, cmd:Cmd )
      native_global_methods[full_signature] = cmd
      .begin_staging

    method register_global_method( full_signature:String, callback:Function()->Variant )
      register_global_method( full_signature, CallNativeMethod(t,callback) )

    method register_method( full_signature:String, cmd:Cmd )
      native_methods[full_signature] = cmd
      .begin_staging

    method register_method( full_signature:String, callback:Function()->Variant )
      register_method( full_signature, CallNativeMethod(t,callback) )

    method register_type(
        scoped_name:String,
        instance_of=null:Function(Variant)->Logical,
        base_class_name=null:String,
        get_singleton=null:Function()->Variant,
        set_singleton=null:Function(Variant),
        variant_type=Variant.TYPE_OBJECT:Int
      )
      native_types[scoped_name] = NativeTypeInfo(
        instance_of, base_class_name, get_singleton, set_singleton, variant_type
      )

    method unload( file:File )
      .begin_staging

      local filepath = file.abs.filepath
      new_elements.remove( filepath )
      resolved_elements?.remove( filepath )

    method update
      try
        launch
      catch (error:Exception)
        new_elements = null
        throw error
      endTry

    method .begin_staging
      if (not new_elements)
        if (resolved_elements)
          new_elements = resolved_elements.cloned
        else
          new_elements = [String:ProgramElements]
        endIf
      endIf

    method .find_file( file:File )->File?
      local found_file = File( resolve_filepath(file) )
      contingent
        sufficient (found_file.exists)

        forEach (folder in include_folders)
          found_file = File( resolve_filepath(folder / file) )
          if (not found_file.exists)
            found_file = File( resolve_filepath(found_file.with_extension(".rogue")) )
          endIf
          sufficient (found_file.exists)
        endForEach

        return null

      satisfied
        file = found_file
      endContingent

      if (file.is_folder) file = (file / file.filename) + ".rogue"

      file .= abs

      local folder = file.abs.folder
      include_folders[folder] = folder

      return file

endClass
