module RogueScript

class Type : Cmd
  PROPERTIES
    batch_id             : Int

    module_context       : Module
    definition           : Class

    attributes           : Attributes
    base_class           : Type
    aspects              : Type[]

    name                 : String
    scoped_name          : String
    element_type         : Type
    is_optional_type     : Logical
    native_instance_of   : Function(Variant)->Logical
    native_get_singleton : Function()->Variant
    native_set_singleton : Function(Variant)
    variant_type         = Variant.TYPE_OBJECT : Int

    global_methods         = [String:GlobalMethod]
    global_methods_by_name = [String:GlobalMethod[]]
    methods                = [String:Method]
    methods_by_name        = [String:Method[]]
    definitions            = [String:Cmd]
    global_properties      = [String:Property]
    global_property_values = [String:Variant]
    properties             = [String:Property]

    visiting  : Logical
    resolved  : Logical

    singleton_value : Variant
    m_init_class    : GlobalMethod
    m_init_object   : Procedure
    m_init          : Procedure

  METHODS
    method init( t, name )

    method init( t, element_type )

    method init( t, element_type, is_optional_type )

    method init( t, module_context, name, attributes )
      if (not attributes.classification) attributes.is_object = true

    method init( existing:Type )
      prior.init( existing )
      name = existing.name
      if (existing.element_type) element_type = existing.element_type.cloned
      is_optional_type = existing.is_optional_type

    method init_object
      batch_id = Parser.current_batch_id

    method add( m:GlobalMethod )
      println StackTrace()
      add_global_method( m )

    method add( m:Method )
      println StackTrace()
      add_method( m )

    method add_global_method( m:GlobalMethod )
      if (not m.type_context) m.type_context = this
      m.organize

      block existing_m = global_methods[ m.signature ]
        if (existing_m and existing_m.type_context is m.type_context and not existing_m.attributes.is_native)
          if (m.attributes.is_native) return
          local m_type = which{ name=="Routine":"routine " || "global method $."(this) }
          throw m.t.error( "A $$ already exists."(m_type,m.signature) )
        endIf
      endBlock

      block existing_m = methods[ m.signature ]
        if (existing_m and existing_m.type_context is m.type_context)
          throw m.t.error( "A method $.$ already exists."(this,m.signature) )
        endIf
      endBlock

      if (m.name == "create")
        if (not m.return_type or m.return_type is not this)
          throw m.t.error( "A $ create() constructor must have return-type $."(this,this) )
        endIf
      elseIf (m.name == "init")
        throw m.t.error( "A $ init() constructor cannot be a global method."(this) )
      endIf

      global_methods[m.signature] = m
      if (not global_methods_by_name.contains(m.name))
        global_methods_by_name[m.name] = GlobalMethod[]
      endIf
      global_methods_by_name[m.name].add( m )

    method add_method( m:Method )
      if (not m.type_context) m.type_context = this
      m.organize

      block existing_m = global_methods[ m.signature ]
        if (existing_m)
          throw m.t.error( "A global method $.$ already exists."(this,m.signature) )
        endIf
      endBlock

      block existing_m = methods[ m.signature ]
        if (existing_m and existing_m.type_context is m.type_context and not existing_m.attributes.is_native)
          if (m.attributes.is_native) return
          throw m.t.error( "A method $.$ already exists."(this,m.signature) )
        endIf
      endBlock

      if (m.name == "init")
        if (m.return_type)
          throw m.t.error( "A $ init() constructor cannot have a return-type."(this) )
        endIf
      elseIf (m.name == "create")
        throw m.t.error( "A $ create() constructor must be a global method."(this) )
      endIf

      methods[m.signature] = m
      if (not methods_by_name.contains(m.name))
        methods_by_name[m.name] = Method[]
      endIf
      methods_by_name[m.name].add( m )

    method add_global_property( p:Property )
      p.type_context = this
      if (global_properties.contains(p.name))
        throw p.t.error( "A global property named '$' already exists."(p.name) )
      endIf
      global_properties[p.name] = p

    method add_property( p:Property )
      p.type_context = this
      if (properties.contains(p.name))
        throw p.t.error( "A property named '$' already exists."(p.name) )
      endIf
      properties[p.name] = p

    method collect_base_types
      if (not definition) return

      forEach (base_type in definition.base_types)
        base_type = module_context.must_find_type( base_type.t, base_type.name )
        if (base_type.attributes.is_aspect)
          ensure<<aspects>>
          aspects.add( base_type )
        elseIf (base_type.attributes.is_object == this.attributes.is_object)
          base_class = base_type
        else
          throw t.error( "[INTERNAL] Unhandled type attributes for base type " + base_type )
        endIf
      endForEach

    method collect_global_methods( method_name:String )
      local methods = global_methods_by_name[ method_name ]
      if (methods) CallCandidates.add( forEach in methods )

    method collect_methods( method_name:String )
      local methods = methods_by_name[ method_name ]
      if (methods) CallCandidates.add( forEach in methods )

    method create_class_initializer
      if (global_properties.count)
        m_init_class = GlobalMethod( t, "init_class" )
        forEach (p in global_properties)
          local cmd_initial_value : Cmd
          if (p.initial_value) cmd_initial_value = p.initial_value.cloned
          else cmd_initial_value = CreateDefaultVariant( t, p.type  )
          m_init_class.statements.add( WriteGlobalProperty(t, p, cmd_initial_value) )
        endForEach
        add_global_method( m_init_class )
      endIf

    method create_init_object_methods
      if (properties.count)
        local m = Method( t, "init_object" )
        add_method( m )
        forEach (p in properties)
          if (p.initial_value)
            m.statements.add( Assign(p.t, Access(p.t,p.name), p.initial_value) )
          else
            local value : Variant
            which (p.type.variant_type)
              case Variant.TYPE_UNDEFINED: value = Variant()
              case Variant.TYPE_BYTE:      value = Byte(0)
              case Variant.TYPE_CHARACTER: value = '\0'
              case Variant.TYPE_INT32:     value = 0i
              case Variant.TYPE_COLOR:     value = Graphics::Color(0)
              case Variant.TYPE_INT:       value = 0
              case Variant.TYPE_INT64:     value = 0I
              case Variant.TYPE_REAL32:    value = 0r
              case Variant.TYPE_REAL:      value = 0
              case Variant.TYPE_REAL64:    value = 0R
              case Variant.TYPE_DEGREES:   value = Degrees(0)
              case Variant.TYPE_RADIANS:   value = Radians(0)
              case Variant.TYPE_LOGICAL:   value = false
              case Variant.TYPE_NULL:      value = null
              case Variant.TYPE_ANCHOR:    value = Anchor(XY(0,0))
              case Variant.TYPE_XY:        value = XY(0,0)
              case Variant.TYPE_XYZ:       value = XYZ(0,0,0)
              case Variant.TYPE_XYZW:      value = XYZW(0,0,0,0)
              case Variant.TYPE_LINE:      value = Line(XY(0),XY(0))
              case Variant.TYPE_CIRCLE:    value = Circle(XY(0),0)
              case Variant.TYPE_TRIANGLE:  value = Triangle(XY(0),XY(0),XY(0))
              case Variant.TYPE_BOX:       value = Box(0,0,0,0)
              case Variant.TYPE_QUAD32:    value = Quad(XY(0),XY(0),XY(0),XY(0))
              case Variant.TYPE_OBJECT:    value = null
              case Variant.TYPE_STRING:    value = null
              case Variant.TYPE_LIST:      value = null
              case Variant.TYPE_TABLE:     value = null
              others: throw p.t.error( "[INTERNAL] Unhandled variant type in Type.create_init_object_methods()." )
            endWhich
            m.statements.add( WriteThisPropertyValue(p.t,p,value) )
          endIf
        endForEach
      endIf

    method description->String
      return name

    method inherit_properties
      if (visiting) return
      visiting = true

      if (base_class) inherit_properties( base_class )
      if (aspects)
        forEach (a in aspects)
          inherit_properties( a )
        endForEach
      endIf

    method inherit_properties( of_type:Type )
      of_type.inherit_properties

      forEach (base_p in of_type.global_properties)
        local this_p = global_properties[base_p.name]
        if (this_p)
          throw this_p.t.error( "Global property '$' already exists in a base type and cannot be redefined." (base_p.name) )
        else
          global_properties[base_p.name] = base_p
        endIf
      endForEach

      forEach (base_p in of_type.properties)
        local this_p = properties[base_p.name]
        if (this_p)
          if (this_p.type)
            if (this_p.type is not base_p.type)
              throw this_p.t.error( "Inherited property '$' redefined with different type."(base_p.name) )
            endIf
          else
            this_p.type = base_p.type
          endIf
        else
          properties[base_p.name] = base_p
        endIf
      endForEach

    method inherit_methods
      if (base_class) inherit_methods( base_class )
      if (aspects)
        forEach (a in aspects)
          inherit_methods( a )
        endForEach
      endIf

    method inherit_methods( of_type:Type )
      of_type.inherit_methods

    method instance_of( ancestor_type:Type )->Logical
      if (this is ancestor_type) return true
      if (base_class and base_class.instance_of(ancestor_type)) return true
      if (aspects)
        forEach (a in aspects)
          if (a.instance_of(ancestor_type)) return true
        endForEach
      endIf
      return false

    method resolve
      if (resolved) return
      resolved = true
      Resolver.resolve_type( this )

    method scoped_name->String
      if (@scoped_name) return @scoped_name
      @scoped_name = "$::$"(module_context,name)
      return @scoped_name

    method to->String
      return name

    method validate_properties
      forEach (p in global_properties)
        if (not p.type)
          if (p.initial_value)
            p.type = p.initial_value.type
            if (not p.type)
              throw p.t.error( "Unable to infer type of global property '$' from initial value."...
                " Add ': TypeName' to explicitly declare type." (p.name) )
            endIf
          else
            throw p.t.error(
              "Cannot determine type of global property '$' - add '= initial_value' or ': TypeName'."(p.name)
            )
          endIf
        endIf
      endForEach

      forEach (p in properties)
        if (not p.type)
          if (p.initial_value)
            p.type = p.initial_value.type
            if (not p.type)
              throw p.t.error( "Unable to infer type of property '$' from initial value."...
                " Add ': TypeName' to explicitly declare type." (p.name) )
            endIf
          else
            throw p.t.error(
              "Cannot determine type of property '$' - add '= initial_value' or ': TypeName'."(p.name)
            )
          endIf
        endIf
      endForEach

    method validate_type_hierarchy
      validate_type_hierarchy( this )

    method validate_type_hierarchy( extended_type:Type )
      contingent
        visiting = true
        if (base_class)
          sufficient (base_class is this)
          necessary (not base_class.visiting)
          base_class.validate_type_hierarchy( extended_type )
        endIf
        if (aspects)
          forEach (a in aspects)
            sufficient (a is this)
            necessary (not a.visiting)
            a.validate_type_hierarchy( extended_type )
          endForEach
        endIf
        visiting = false
        return

      satisfied
        throw t.error( "Circular class extension - class $ cannot extend itself."(name) )

      unsatisfied
        local a_name = extended_type.name
        local b_name = name
        if (module_context is not extended_type.module_context)
          a_name = extended_type.scoped_name
          b_name = scoped_name
        endIf
        throw t.error( "Circular class extension - class $ already extends $."(a_name,b_name) )

      endContingent

endClass

